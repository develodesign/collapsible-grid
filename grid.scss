/**
 * Variables
 *
 * Name for the grid and screen sizes. Default screen sizes taken from Bootstrap.
 */
$grid-name-prefix: 				'row' !default;
$grid-item-name: 				'column' !default;

$screen-xs:                  	480px !default;
$screen-sm:                  	768px !default;
$screen-md:                  	992px !default;
$screen-lg:                  	1200px !default;
$screen-xl: 					1600px !default;

/**
 * Define the grids we want to make.
 * Grid points contain the number of columns and the min-width set for the media query
 * Must be made with the largest media queries first.
 */
$grids: (
				(
								( 12, $screen-xl ),
								( 6, $screen-lg ),
								( 4, $screen-md ),
								( 3, $screen-sm ),
								( 2, $screen-sm / 1.5 ),
								( 1, null )
				),
				(
								( 4, $screen-md ),
								( 2, null )
				),
				(
								( 6, $screen-md ),
								( 3, null )
				),
				(
								( 2, null )
				),
				(
								( 3, null )
				)
) !default;

/**
 * Returns a percentage based on the number of columns.
 */
@function get-column-width( $number-of-columns: 1 ){

  @return percentage( 100 / $number-of-columns / 100 );
}

/**
 * Work out what the grid should be called based on all the grid points
 */
@function get-grid-name( $points ){

  $grid-name: $grid-name-prefix + '-';

  $counter: 1;

  // Get the class name of the grid
  @each $point in $points {

	@if( $point ){

	  $grid-name: $grid-name + nth( $point, 1 );

	  @if type_of( $point ) == 'list' and $counter != length( $points ) {

		// Safe to presume this isn't the last grid point
		$grid-name: $grid-name + '-to-';
	  }
	}

	$counter: $counter+1;
  }

  @return $grid-name;
}
/**
 * Create a grid item
 *
 * @param $number-of-columns {integer} Contains number of columns.
 * @param $width {percentage} Expects percentage but can really be any valid css width value.
 */
@mixin grid-item( $number-of-columns, $width ){

  width: #{$width};

  @if( $number-of-columns > 1 ){

	&:nth-child( #{$number-of-columns}n +1 )
	{
	  clear: left;
	}
  }
}

/**
 * Create a collapsible grid item
 *
 * @param $number-of-columns {integer} contains number of columns.
 * @param $min-width {integer} min width for the media query the grid item becomes active.
 * @param $max-width {integer} if specified will add the max width to the media query.
 */
@mixin collapsible-grid-item( $number-of-columns, $min-width: null, $max-width: null ){

  $width: get-column-width( $number-of-columns );

  @if( $max-width and $min-width ){

	@media (min-width: $min-width ) and (max-width: $max-width)
	{
	  @include grid-item( $number-of-columns, $width );
	}
  }

  @else if( $min-width ) {

	@media (min-width: $min-width ){

	  @include grid-item( $number-of-columns, $width );
	}
  }

  @else if( $max-width ) {

	@media (max-width: $max-width){

	  @include grid-item( $number-of-columns, $width );
	}
  }

  @else {

	@include grid-item( $number-of-columns, $width );
  }
}

/**
 * Create a grid name based on how the grid items will collapse. For example grid-4-to-2 will collapse from four columns
 * to two.
 */
@mixin collapsible-grid( $points ){

  $grid-name: get-grid-name( $points );

  .#{$grid-name}
  {
	@include clearfix();

	> .#{$grid-item-name}
	{
	  float: left;

	  @include box-sizing( border-box );

	  $previous-width: null;
	  $min-width: null;

	  @each $point in $points {

		$number-of-columns: nth( $point, 1 );

		@if( length( $point ) > 1 ) {

		  $min-width: nth($point, 2);

		  @include collapsible-grid-item( $number-of-columns, $min-width, $previous-width );

		  $previous-width: nth($point, 2);
		}

		@else if( $number-of-columns ) {

		  $width: get-column-width( $number-of-columns );

		  @include grid-item( $number-of-columns, $width );
		}

	  }
	}
  }
}

/**
 * Spin through the grid points and create a collapsible grid for each one.
 */
@each $grid-points in $grids {

  @include collapsible-grid( $grid-points );
}